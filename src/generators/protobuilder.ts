import * as norman from "norman";
import * as fs from "fs";
import { ManifestGenerator } from "generators/manifestreader";
import * as Case from "case";

type ProtobuffType = "double" | "float" | "int32" | "int64" | "uint32" | "uint64" 
| "bool" | "string" | "bytes";

export class ProtoBuilder extends ManifestGenerator {
    constructor(manifest: norman.QueryManifest, outdir: string) {
        super(manifest, outdir);
    }

    private mapType(manifestType: string): ProtobuffType {
        if (/^varchar/.test(manifestType)) {
            return "string";
        }
        
        return "bool";
    }
    emit() {
        let dest = this.outdir;
        let stream = fs.createWriteStream(dest, { flags: "w" });

        stream.write(`/* These messages were generated by normanc. */\n`)
        stream.write(`syntax = "proto3";\n\n`);
        this.manifest.queries.forEach(query => {
            let requestName = Case.pascal(query.name);
            stream.write(`message ${requestName} {\n`);

            let requestFields : string[] = [];
            for (let i = 0; i < query.parameters.length; i++) {
                let param =  query.parameters[i];
                let pname = Case.camel(param.name);
                let type = Case.camel(this.mapType(this.lookupType(param.type)));
                stream.write(`\t${type} ${pname} = ${i+1};\n`)
            }

            stream.write(`}\n`)
            let responseName = Case.pascal(`${query.name}.response`);
            stream.write(`message ${responseName} {\n`);
            let fidx = 1;
            for (let field of query.effect.select) {
                let fname = Case.camel(field);
                let ftype = Case.camel(this.mapType(this.lookupType(field)));

                stream.write(`\t${ftype} ${fname} = ${fidx};\n`)
                fidx++;

            }
            stream.write(`}\n\n`);

        });

        stream.end();
    }
}